---
title: 我的算法日记
date: 2021-11-19
tags:
 - 算法
categories:
 - 工具

---

算法不是一天两天可以练成的，日以继夜，与君共勉

<!-- more -->

## 链表

特点：适合快速插入和删除，不适合快速定位

主要技巧：

### dummy虚拟节点

为了防止空指针的出现，比如长度为5的链表要删除倒数第五个节点，那么按理要找到倒数第六个和倒数第四相连，但这时候找倒数第六就会出现空指针异常

### 快慢指针（双指针）

应用非常广泛，比如

- 找到链表的中点
- 判断是否有环（如果有环，那么快慢节点迟早相遇）
- 找到倒数第N个节点（快指针先走N步，直到结束，此时慢节点就是倒数第N个节点）

### 距离相同原理（两个指针走相同的距离相遇）

- 找到开始有环的位置（记录快慢指针相遇的位置，此时慢指针重回head，快慢指针保持相同步频前进，下次相遇的点就是环的起始点）

  - 假设起点到环开始点距离为K，相遇点为环开始点后X，环的长度是M

  - 此时慢指针总共走过 K + X

  - 快指针总共走过 K + M * N(N为大于2的整数) + X

  - 慢指针距离 * 2 = 快指针距离

  - 2(K + X) = K + M * N +X

  - 除项移项得到 K = M * N - X

  - 由此可以推断从起点和初相遇点两边同时单步走K距离时，快指针恰好在入口处，因为M * N就是回到原地，-X就退回到了环起点

- 判断两个不等长的链表是否有相交（尾部相交，后面没有延伸）

  - 核心就是怎么让AB两个指针同时达到C1
  - 假设两个链表的长度为X和Y，相交的长度为M(>=0)
  - A走X + (Y - M)步，走自身的长度，然后走B不想交部分的长度
  - B走Y + (X - M)步
  - 两者距离相等，且当M > 0时下一个节点必然是相交点，否则就是null节点
  - 回到代码，就是AB节点同时从自己开始走，走完自己后，开始从对方的head走，然后必然会走到A.val === B.val的相遇节点，此时如果不是null的话，那就是相交了

![image-20211119170250378](https://kuimo-markdown-pic.oss-cn-hangzhou.aliyuncs.com/image-20211119170250378.png)



## 队列

特点：先进先出 FIFO

主要技巧：

- 取模

在做循环队列时，比如10位的队列，在`9`的位置上添加新元素，那新元素会在`0`的位置上，如何得到就需要`(9 + 1) % 10 = 0` 。 同理，当第0位的元素，找上一个元素时，`(0 - 1) % 10`就会出现负数，此时可以`(0 - 1 + 10) % 10 = 9`得到正确的位置



## 通用技巧

因为js里面0直接去判断非空会为false，所以有的时候0为有意义的值的时候，比如记录指针下标，最后要判断下标是不是为空。如果这时候把空指针用`null`来指定，那接下来所有的判断都要加上`x !== null` 非常不方便，可以将下标设置为`-1`，然后判断是不是大于等于0就好