## 目标

1. 抽离FDP，使其成为一个稳定的可迭代版本，去除现有各种后端开关，后续跟随dice版本一起升级。
2. 独立CDP，创建一个可独立运行的壳，包含登陆验证，路由导航等功能。
3. 继续保持CDP包的导出形式，可以支持类似美孚这样的宿主应用成为一个XDP，做到即插即用。

## 现状

- FDP和CDP目前的开发模式是，每到某个应用的开发周期，从develop分支拉取一个feature分支，开发结束后合并到develop，同时merge到一个特定的release分支（release/dice或release/exxon），然后不论美孚还是dice需要装对应的包都从对应的release分支下载对应版本。
- 由于两个应用共用一个工程，所以免不了有各种环境的开关来标示运行在dice还是美孚，在项目的长期维护中，不管前端还是后端都容易把开关弄混，经常在dice迭代中，测试会发现原有的功能变化了，没有被通知的功能意外出现了，而这些都不在迭代需求中。

## 实现想法

1. 把FDP单独出来，成为一个新的包，或者直接把代码全部迁入dice本体，在这个新的实现上，我们可以摆脱nusi 2.x与3.x的兼容问题，专心将FDP升级成nusi 3.x。同时将之前的各种开关全部去除，接口方面统一使用`/api/fdp`前缀，这样不仅带来代码的稳定性，也带来了测试功能的稳定性。后续XDP对FDP是没有依赖继承的关系的，两边独立开发迭代。
2. CDP实现两种部署模式，一种就是现有的组件导出形式，通过npm包导出给宿主一起打包部署，第二种就是为CDP创建一个自己的壳，需要接入登陆等功能。
3. 考虑XDP的二开机制
   1. 一种是类似会员的标品同名文件二开方式，这种方式的好处是对源代码无侵入，新功能的实现者不限定是CDP的原始开发者也可以是别的组的成员，但这种模式有个比较坑的地方是，如果标品的代码是不稳定的，那么如果CDP本体更新了，而二开功能没有及时调整就会有各种意想不到的bug，同时有时调整的代价也不小。其次，这种二开模式需要开放更多的全局变量，比如目前CDP的前缀是`/api/cdp`，那么将来某个变成XDP，即使是老功能也需要把前缀都替换成`/api/xdp`，而这些不可能都通过覆盖文件来实现，必须提前想好适配的方案。
   2. 继续使用当前包的形式，沿用后端开关的方式来控制功能点。开关不是简单的区分环境而是区分功能点，这个实现的一个前提就是产品能够足够明晰，一个具体功能点在N个DP中的差异，不能像现在这样加开关过于随意。
4. 将来CDP工程，只维护一个release分支。

## 成本

1. 将来所有FDP和XDP的新功能或bug如果要互相迁移，那都需要手工拷贝代码，而不能像现在通过git merge/pick来实现，会有一定风险。
2. UI组件上，XDP应该暂时不会升级nusi 3.x，所以很长时间内组件用法、样式可能不同，迁移时需要注意。
3. XDP独立后不对dice负责，可以有专门的开发资源来负责开发，将来不会出现因为XDP的进度挤占到dice开发资源的问题