各位评审大佬下午好，

##### 个人介绍

我是2012年毕业于浙江大学软件工程专业，随后加入了我的研究生导师公司合资的一家外企，也就是美国道富，并且在那里度过了6年的时间，但是在此期间，我的主要工作是做Java后端开发。虽然主要是做后端，但还是陆续接触了asp.net，jsp，flex，JWT等前端技术，直到18年初开始接手一个新的前端项目，是用React做开发的，从此将主要的精力投入在前端上。在2018年的年底，我加入了端点，进入了当时的dice前端组，这也是我第一份全职的前端工作。在19年的x月，我开始投入到了美孚的项目中，并担任CDP前端的负责人。在20年的x月，erda的快数据平台成立，我作为这个模块的前端负责人一直到现在。

#### 项目介绍

在开始以下的陈述之前，我想要提前声明一下，以下所有的陈述内容都是我个人的思考与实现，我绝对不会拿其他同事的劳动成果放在我个人的PPT当中。

我想传统的晋升述职应该会先把过去一段时间所做的所有业绩都体现一下，比如，我完成了多少客户需求、产品需求，完成了多少迭代，多少版本的升级等等。 但是时间原因，我想把这些内容都尽量省略掉，并不是因为我觉得这些内容不重要，而是我想用更多的时间来分享我在过去两年多时间的思考和总结。那么以下是我选取的几个个人认为比较有代表性的个人思考案例。

##### 微前端1.0

OK，关于微前端，首先交代下背景。在最开始的时候我们在美孚这个项目上开发了一个数据平台叫做CDP，但是这个项目内容是要为我erda所用的，即要抽取出其中一大部分功能，拿回到erda中，成为erda自己的数据平台即我们熟悉的FDP。这是一个high level的愿景，即写一份代码，在两个项目上都能顺利运行。于是我们最初的方案是单独起一个项目，最终的输出是一个npm包，主要导出路由和组件，在宿主环境下编译，基本达到了最初的目的。但是随着项目的进行一些始料未及的问题涌现了出来

1. 由于必须在宿主项目上编译打包（因为本身不是一个library），所以就高度依赖了宿主的技术架构，打个比方开始大家都是Antd 3.x，做着做着一边升级4.x了。此时项目就容易夹在中间出现不兼容的问题
2. 因为本身体量不小，就大大增加了宿主项目的打包时间，产生巨大的编译负担，同时容易在打包中带崩宿主
3. 样式污染和全局变量问题，表现形式就是本地看起来一切正常，一和宿主集成就各种牛鬼蛇神

为此，如何做到一个既能独立技术栈独立打包，又能完美兼容宿主的前端应用成为了我实现的目标。而微前端则顺理成章得成为了我重要的抓手，在调研了Iframe、single-spa、qiankun等实现方式之后，最终选择了qiankun作为实现微前端的手段。虽然qiankun非常简单，看起来一天就能入门上手，但是做到从开发到部署生产，都稳定如预期，需要花费大量的时间去试错踩坑。比如，服务挂了怎么办？如何协同SRE部署一个新的应用？如何确保没有样式污染？如何共享用户信息？等等。 最终我在一个迭代的时间里将FDP的微服务化成功落地，并一直稳定运行至今。

##### 微前端2.0

随着qiankun的落地，erda不再不需要打包FDP相关模块的代码了，但随之引来一个问题。即qiankun是根据路由在应用加载，只能做到应用级别的微前端，一旦遇到需要单独导出一个组件就无法实现。此时的需求就是在erda的全局菜单栏上添加一个FDP选取集群空间的组件，其实为了快速完成这个需求，我可以完全把这个组件写在erda的项目中。但这样就变成了一个完全耦合的结构设计，是我无法接受的。

为此我经过调研，发现webpack 5提供的模块联邦的功能是一个可行的解决方案，但因为这项技术推出的时间非常短，不像qiankun（qiankun我相信在我之前端点肯定有同学使用过，但模块联邦我盲猜我应该是端点第一个使用的人），网络上几乎没有太大可借鉴的经验。我也是自己摸石头过河，主要需要解决几个问题

1. 如何做到样式的隔离
2. 如何做到ts类型的补全
3. 单独导出的组件如何使用公共的资源
4. 如果导出失败，如何保证页面不崩溃

最终也是在一个迭代内成功实现了组件的导出，逻辑的解耦。更重要的意义是，模块联邦也成为了erda-ui新架构分割模块的技术实现方式。

##### 国际化思考1.0

在19年，dice前端开始搞国际化，在那个过程中，我们总结实践出了一套国际化的流程，具体大致分为7步。在步骤繁琐的同时还有一些问题。

1. 无法复用原先已经翻译过的内容，比如要翻译的中文是“确定”，虽然之前的locale资源中已经有对应的翻译，但还是需要走一遍流程来做翻译
2. 英文展示不直观
3. 翻译原文中带有特殊字符如冒号，会导致脚本失败



##### 国际化思考2.0

虽然有了上面的i18n脚本，通过交互式的命令行操作把国际化的整个流程都串联起来，做到了一个命令完成国际化所有操作的流程。但这样依然会有一个额外的命令步骤要走。让这个毫无技术含量的工作还是显得过于有负担。于是乎想到，有没有一种手段，可以让整个国际化做到无感知无负担。换言之就是如何在编码的同时自动把国际化给做了， 进一步想到能否在编译工具上找到突破点。于是我先开始尝试写一个webpack loader或者plugin来实现。 首先要解决的问题是如何抽取出源代码中的i18n.d，两种解决方法，

1. 用正则匹配，优点是简单，缺点是容易受到格式的影响，甚至注释都会被错误得匹配
2. 用ast语法树来匹配，通过找到callExpression, 直接消除了准确率的担忧

loader or plugin？

- loader需要自己去做一遍ast树的解析全过程，虽然可以借助babel来实现，但是就是给每个源文件额外加了一层转换，性能上并不好
- plugin 可以写一个babel-loader或者ts-loader的plugin，直接获取这些loader解析后的结果，然后直接做转换，省去了额外解析的步骤。

除此之外，还有其它额外的加强

1. 加入了谷歌自动翻译脚本，省去手动翻译过程
2. 自动化管理国际化的命名空间。 要知道之前如果要把一个翻译从A命名空间迁移到B命名空间，是一件非常痛苦的事情，所以即使让它冗余也不愿意做，但有了插件之后一切都变得自动可控起来

其实按照这个思路走，接下来我还打算继续在前端埋点上做些文章。



##### API层优化改造的思考和实现1.0

当前service层的现状

1. 冗余代码太多
2. 无法严格控制必须写入参出参的类型
3. 无法保证service方法纯净性
4. 一些可以抽象的操作无法复用，比如上传下载、弹出提示等

结果：

1. api层不再有冗余的代码
2. 所有api层方法都保证有自定义的出入参类型，杜绝any

##### API层优化改造的思考和实现2.0

凡事我们都争取多想一层，上面我们说到api层改造去除了大量冗余的代码，但在我看来冗余代码不仅只在api层，更多的是在api的调用层状态管理层。 一直以来erda-ui都是以dva的一套结构来做状态管理，后来为了提升ts的类型提示等原因替换成了骏总写的cube-state，但整体的逻辑是没有变化的，只是从hoc转变成了hooks。特别是在api调用方面必须遵循一套范式，即所有的请求都要经过store层，然后在store中调用service层的方法，最后再返回给页面。这个范式在dice施行了很久，但我觉得其中还是有一些问题

据个人不负责任的统计，在中台前端页面中，超过95%的数据是没有必要存放在store中的，强行存放只会带来三个后果

1. 内存占用随着访问页面越来越多而越来越大
2. 用户第二次访问之前访问过的页面，第一下看到的都是过期的数据
3. 当出现问题时，排查问题的链路变得更长了，因为调用api的参数和api返回的结果，同时可能在页面和store中发生转换，逻辑不内聚。应该页面干页面相关的逻辑，store做存储的逻辑，而api只做调用请求的逻辑，各自独立边界要清晰

所以我接下来做的事情，，直接在页面中调用api方法。但这里又必须要解决在脱离了状态管理层后的一些全局控制问题

1. 如何控制api的loading状态？
2. 如何自动组装各种分页信息？
3. 如何自动弹出错误信息？
4. 如何管理userInfo

我认为好的代码不在于数量多少，而在抽象程度高低，如果有一堆看似合理的代码，但实际并没有存在的必要时，我们就应该把它们清除出去。 所以最终的结果是，我把FDP中，大约70%以上的store都直接干掉了， 在减少了总的代码量的同时，简化了开发流程，明晰了模块边界



##### 样式污染解决之道

刚才我们讲了很多关于微前端的内容，其中有个绕不过去的点就是样式污染和样式隔离。特别是在monorepo和微前端当道的今天，

##### 团队贡献





##### 晋升理由





## 未来展望