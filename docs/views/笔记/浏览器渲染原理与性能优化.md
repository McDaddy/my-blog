---
title: 【笔记】- 浏览器渲染原理与性能优化总结
date: 2020-05-25
tags:
 - 浏览器
 - 优化
categories:
 - 笔记


---

## 进程与线程

- 进程包含线程，进程是操作系统资源分配的基本单位
- 线程由进程管理
- 为了提升浏览器的稳定性和安全性，浏览器采用的是多进程模型

### 浏览器中的五个进程

![img](https://kuimo-markdown-pic.oss-cn-hangzhou.aliyuncs.com/browser.7559b8c7.png)

- 浏览器进程： 负责主界面显示、用户交互、子进程管理，提供存储等。
- 渲染进程： 每个tab卡都是单独的渲染进程，核心用于渲染页面。
- 网络进程： 主要处理网络资源加载(`HTML`、`CSS`,、`JS`等)
- GPU进程： `3d`绘制,提高性能
- 插件进程： 负责插件运行的进程



## 从输入URL到浏览器显示页面发生了什么?

如果输入的是关键字那么会调用默认的搜索引擎，否则如果是合法url，则开始以下步骤

粗略得讲总共4步，可以说是浏览器几个进程之间的互相协作过程，进程间通信用IPC：

1. 做url的地址导航，并准备渲染进程
2. 在网络进程中发送请求，相应后的结果交给渲染进程处理
3. 解析页面（HTML），并加载需要的资源
4. 渲染页面，展示结果

网络的七（四）层模型： （物 数） （网ip）（传tcp 安全可靠 分段传输/udp 会丢包速度快不需要握手）  （会 表 应）

### URL请求过程

1. 查找强缓存，是否过期
2. 查看域名是否被解析过，有的话直接从浏览器缓存拿，否则进行DNS解析（基于UDP），将域名转成IP，并增加端口号
3. 如果是`HTTPS`，那要做`SSL`的协商
4. 利用IP地址做寻址请求，同一域名下请求数不能超过6个
5. 与服务器做TCP连接，即三次握手
6. 发送HTTP请求（请求行，请求头，请求体）
7. 利用TCP协议将大文件拆成数据包进行有序传输，可以做到丢包重传，服务器收到后按照序号重排数据包 （增加`TCP`头部，`IP`头部）
8. 服务器响应结果（响应行，响应头，响应体）
9. 返回状态码为301、302时，浏览器会进行重定向操作。（重新进行导航）
10. 返回304则查找缓存。（服务端可以设置强制缓存）
11. `HTTP 1.1`中支持`keep-alive`属性,TCP链接不会立即关闭，后续请求可以省去建立链接时间。

#### 如何看network timing

![img](https://kuimo-markdown-pic.oss-cn-hangzhou.aliyuncs.com/jd.f840386b.png)

- `Queuing`: 请求发送前会根据优先级进行排队，同时每个域名最多处理6个TCP链接，超过的就会进行排队，并且分配磁盘空间时也会消耗一定时间。
- `Stalled` :请求发出前的等待时间（处理代理，链接复用）
- `DNS lookup` :查找`DNS`的时间
- `initial Connection` :建立TCP链接时间
- `SSL`: `SSL`握手时间（`SSL`协商）
- `Request Sent` :请求发送时间（可忽略）
- `Waiting`(`TTFB`) :等待响应的时间，等待返回首个字符的时间
- `Content Dowloaded` :用于下载响应的时间

### HTTP的发展历程

- HTTP/0.9：没有请求头和请求体，服务器返回也没有头信息，只是为了传输HTML存在
- HTTP/1.0: 增加了请求头和响应头，实现了除HTML之外的多类型数据传输
- HTTP/1.1: 默认开启了持久链接（keep-alive），在一个TCP链接上可以传输多个HTTP请求。每个域名可以最多维护6个TCP持久链接，即采用**管线化**的方式来并发请求，但是服务器接收请求还是按顺序处理返回的，这就会造成队头阻塞问题。支持了数据分开传输，引入了客户端cookie机制。
- HTTP/2.0 用一个TCP链接来发送数据，一个域名一个TCP链接，即多路复用（原理为二进制分帧）。 头部压缩减少体积，服务器可以主动推送给客户端
- HTTP/3.0 解决了TCP的队头阻塞问题，QUIC协议，采用UDP

### 为什么css放在header里，js要放在底部？

css如果放在底部，那么有可能会**发生重绘**，因为当html渲染时，渲染从上到下，边解析边渲染（没有样式的前提下），在还没解析到css部分的时候就已经把之前的dom部分渲染好了，此时再加载css，就会对dom进行二次渲染。相反，如果把css放在头部，当渲染dom时，是必须要等待样式加载完毕才会渲染，所以说css的资源加载**不会阻塞**HTML的解析，但是**会阻塞**dom的渲染

JavaScript**会阻塞**HTML的解析，也**会阻塞**dom的渲染，如果把js放在文件的头部或中间，就会把整个渲染过程割裂开，当解析到js部分时就必须先执行js，然后再执行后续的解析。 同时css的加载**会阻塞**js的执行，因为js要保证能够操作页面样式时才开始执行。js为什么会阻塞dom渲染，因为js也是可以操作dom的，如果页面渲染和js并行，那么js就有可能操作到不符合预期的dom了

总结为下图，主流程就是下图的第一行，浏览器会预解析HTML文件，看里面有没有css和js的外链，然后并发去请求，当返回后，dom的渲染依赖js的执行完毕，而js的执行开始依赖于css的解析完毕

![img](https://kuimo-markdown-pic.oss-cn-hangzhou.aliyuncs.com/browerrender.jpg)

### 渲染流程

![img](https://kuimo-markdown-pic.oss-cn-hangzhou.aliyuncs.com/timg.5bac37a6.jpg)

1. 浏览器无法直接使用HTML，需要将HTML转化成DOM树。（document）
2. 浏览器无法解析纯文本的CSS样式，需要对CSS进行解析,解析成styleSheets。CSSOM（document.styleSeets）
3. 计算出DOM树中每个节点的具体样式（Attachment）
4. 创建渲染（布局）树，将DOM树中可见节点，添加到布局树中。并计算节点渲染到页面的坐标位置。（layout）
5. 通过布局树，进行分层 （根据定位属性、透明属性、transform属性、clip属性等）生产图层树
6. 将不同图层进行绘制，转交给合成线程处理。最终生产页面，并显示到浏览器上 (Painting,Display)

## Perfomance API

![img](https://kuimo-markdown-pic.oss-cn-hangzhou.aliyuncs.com/timing-overview.7e63b017.png)