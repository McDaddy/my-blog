---
title: 模块联邦详解
date: 2021-04-01
tags:
 - Webpack
 - 模块联邦
categories:
 - 前端工程化



---

## 什么是模块联邦

> Code sharing coordinated at runtime   — Zack Jackson

## 想要解决的问题

### 扩展难题

- 中型项目向大型项目扩展时，遇到公共代码难以共享的困境
- 如何让独立部署的应用能集成起来，或反之让大型项目做拆分

### 协作难题

- 多开发团队与项目，如何协同开发和部署
- 更简单的微前端解决方案（低成本的学习曲线）
- 避免无意义的CI步骤（不需要去拉取编译无关的项目）

### 性能难题

- 避免三方库的重复加载
- 按需加载

### 共享难题

- 很难得到共享模块的更新（e.g. common模块修复了一个bug，但你完全不知情，还在持续与这个bug斗争）
- 不同团队既可以用同样技术栈（包括version），也可以自由选择技术栈



## 过往的解决方案

### N合1

各个项目可以独立开发，但是无法做到独立部署后集成，当需要做部署时，哪怕只是一行代码的改动，也需要拉取所有用到项目工程的代码，然后统一做CICD，随着项目越做越大，编译部署的速度也变得越来越慢，此时整个项目就是一个巨石项目，耦合性强且难以维护

### Externals

比N合1有更好的编译性能，但所有项目的依赖也因此被锁定在主应用上，无法自由得去定义，非常不灵活

### DLL

同上，各个应用必须依赖于外部的代码定义，集成风险大



## 概念

![image-20210331143419072](https://kuimo-markdown-pic.oss-cn-hangzhou.aliyuncs.com/image-20210331143419072.png)

万物皆可共享，不论是组件、页面还是方法逻辑，简单得理解就是能用`import`引用的东西，理论上都可被共享

### Host

 载入页面时，第一个被加载的webpack build，当页面发生reload，第一个载入的应用变化了，那么host也就随之改变

### Remote

被Host所消费（consume）的webpack build

### Bidirectional Hosts（双向Host）

两个webpack build互相为Host

![image-20210331160134849](https://kuimo-markdown-pic.oss-cn-hangzhou.aliyuncs.com/image-20210331160134849.png)

### Omnidirectional hosts（全面Host）

所有的webpack build都可被认为是host，同时也是consumer，所有模块可以共享同一份的公共依赖，提供了版本协商机制，可以选取出最佳的版本来被共享，如果某个模块的依赖于其他模块不兼容，可以使用其独立的依赖

![image-20210331160245408](https://kuimo-markdown-pic.oss-cn-hangzhou.aliyuncs.com/image-20210331160245408.png)

### 容器

各自独立打包编译，大大提升构建性能

![1608851582909](https://kuimo-markdown-pic.oss-cn-hangzhou.aliyuncs.com/1608851582909.png)



### 全景图

![1608851802459](https://kuimo-markdown-pic.oss-cn-hangzhou.aliyuncs.com/1608851802459.png)





## 实现流程（一个host对一个remote）

1. 加载页面，开始加载host的webpack主构建
2. webpack_require.e("node_modules_babel-loader_lib_index_js_ruleSet_1_rules_1_src_bootstrap_tsx-webpack_sharing_co-9caf20")
3. webpack_require.f.consumes, 发现这个chunk里有shared library
4. 调用shared library的加载方法， 即loadStrictVersionCheckFallback
5. 执行一个init的柯里化高阶函数， 调用webpack_require.I
6. host注册host的依赖, 注册结果是一个对象，包含一个get方法即拿到对应url，from：从哪个app来，eager：是否紧急
7. 执行initExternal，开始初始化remote
8. 加载remote的remoteEntry.js chunk，然后执行remote的init方法，并传入刚才已经完成host注册的shared scope
9. remote注册自己的依赖到shareScope，此时host和remote的shareScope被合并在了一起，并在结束后一并传会给host
10. loadStrictVersionCheckFallback得到整个shared scope，然后依据host的required version运算semver规则得到合适版本（只是给host用的）
11. 加载remote的异步组件，发现它需要react， 会进入remote的loadStrictVersionCheckFallback，依据remote的required version计算得到合适的版本给remote



坑

1. qiankun命名冲突
2. 普通组件没问题，如果导出复杂组件， 如使用了use hook就挂
3. 依赖共享之后出现 **`Uncaught Error: Shared module is not available for eager consumption`**
4. 解决之后组件库无法显示
5. history共享问题
6. ts提示
7. ws影响

![image-20210129181529732](https://kuimo-markdown-pic.oss-cn-hangzhou.aliyuncs.com/image-20210129181529732.png)

Q：在同样版本的share库，到底是从父还是子，还是任意一个子里面取

A：不一定，看package.json中的name，字符串比较谁大就从谁这里取

Q：为什么编译入口都要变成异步的？



## 参考

[Webpack 5 Module Federation - Zack Jackson - CityJS Conf 2020](https://www.youtube.com/watch?v=-ei6RqZilYI&t=2526s)